[{"title":"test1","path":"/2026/01/03/test1/","content":"王道数据结构目录​ 1. 绪论1.1 数据结构基本概念1.1.1 基本概念和术语 数据（单个数，字符之类的）、数据元素（struct） 结构类型 原子类型 结构类型 ADT 数据结构：逻辑结构、存储(物理)结构和数据的运算 1.1.2 数据结构三要素 逻辑结构 graph TD A[数据的逻辑结构] -- B[线性结构] A -- C[非线性结构] %% 线性结构部分 B -- D[受限线性表] B -- E[线性表推广] B -- F[一般线性表] D -- G[栈和队列] D -- H[串] E -- I[数组] %% 非线性结构部分 C -- J[集合] C -- K[树形结构] C -- L[图状结构] K -- M[一般树] K -- N[二叉树] L -- O[有向图] L -- P[无向图] 存储结构 顺序存储 一整块存储单元外部碎片多？占的多但是 随机存取 链式存储 不会出现外部碎片 顺序存取 索引存储 操作系统的 散列存储 哈希存储，根据元素关键字可以计算出该元素的存储地址 数据的运算：增删查改 1.1.3 错题分析3， 1.2 算法和算法评价1.2.1 算法和算法评价 五个重要特征 有穷性 有限时间空间 确定性 相同输出 可行性 输入 输出 好的算法 正确性 可读性 健壮性 非法输入 高效率和低存储量需求 1.2.2 算法效率的度量 时间复杂度 空间复杂度 1.2.3 错题2， 14， 17 2. 线性表2.1 线性表的定义和基本操作2.1.1 线性表的定义 一些概念性的术语 相同数据类型的优先序列、表头元素、表尾元素、直接前驱、直接后继 2.1.2 线性表的基本操作 增、删、查、插、改、打印、判空、表长 2.1.3 错题分析NO 2.2 线性表的顺序表示2.2.1 顺序表的定义 一些术语 线性表的的顺序存储也称线性表、逻辑顺序与其存储的物理顺序相同 LOC(A) 表头再加入每个步长 + sizeof(element) 可访问到地址 可静态分配和动态分配 优点 随机访问 $O(1)$ 存储密度高，每个结点只存储元素 缺点 **插入，**需要移动大量元素，平均 $n2$ ，删除平均移动 $(n-1)2$ 顺序存储分配的是一段连续的存储空间，不够灵活 2.2.2 顺序表上基本操作的实现增删查改 2.2.3 错题2，3，4，6，13 2.3 线性表的链式表示2.3.1 单链表的定义 一些术语 非随机存取、头结点、头指针、尾结点、带表头结点 引入头结点优点 链表的第一个位置与其他操作无异，无须特殊处理 无论链表是否为空，其头指针都是指向头结点的非空指针，空表和非空表的处理得到了统一 2.3.2 单链表上基本操作的实现 $O(n)$ 表长、按位查找、按值查找、插入、删、头插顺序相反、尾插顺序一样 2.3.3 双链表 胖豆都会 prior 2.3.4 循环链表 1. 循环单链表 2. 循环双链表 2.3.5 静态链表 用数组来描述线性表的链式存储结构 以 next = -1 作为结束标志只需要修改指针不需要移动元素 应用在Basic等无指针的高级语言 2.3.6 顺序表和链表的比较 1. 存取方式 顺序表既可以顺序存取、也可以随机存取 链表只能从表头开始依次存取 2. 逻辑结构和物理结构 顺序存储，逻辑相邻物理也相邻，链式存储则物理不一定 3. 查找、插入和删除操作 按值查找均为 $O(n)$ 按位查找顺序表有序可用折半查找 $O(\\log n)$ 按位查找顺序表 $O(1)$ 链表平均时间 $O(n)$ 顺序表的插、删麻烦，得移动很多元素，链表只修改指针域即可 4. 空间分配 很胖豆 选取 基于存储考虑 基于运算考虑 基于环境考虑 2.3.7 错题3，6，7，10，18，23，24，25，26，27，31 3. 栈 队列 数组3.1 栈13.1.1 栈的基本概念 1. 栈的一些术语 先进后出，栈顶， 栈底，空栈 2. 栈的基本操作 InitialStack(), StackEmpty(), Push(), Pop(), GetTop(), DestroyStack() 3. n 个不同元素入栈时，出栈元素不同排列的个数为： $\\frac{1}{n+1} \\C_{2n}^{n}$ 3.1.2 栈的顺序存储结构 栈是一种操作受限的线性表，类似于线性表，两种存储方式 顺序栈 一个指针 top 来指向栈顶 顺序栈的入栈受数组的上界约束 struct int data[Maxsize]; int top; Stack; 基本操作 经典 5 板斧 共享栈 俩指针差 1 栈满 3.1.3 栈的链式存储结构 链栈，单链表，都在表头操作，注意带不带表头 3.1.4 错题9，23，24，25， 3.2 队列3.2.1 队列的基本概念 1. 一些术语 Queue, 先进先出， 出队离队，入队进队 2. 常见操作 5 板斧 3.2.2 队列的顺序存储结构 1. 队列的顺序存储结构 队首front 队尾 rear 会导致队发生上溢出，因此退出了循环队列 2. 循环队列 初始时： Q.front Q.rear 0;队首指针进 1 : Q.front (Q.front + 1) % Maxsize队尾指针进 1 : Q.rear (Q.rear + 1) % Maxsize队列长度：(Q.rear + Maxsize - Q.front) % Maxsize出入队：指针都按顺时针方向进 1 队空的条件是 Q.front Q.rear 但是为来区分队空还是队满 三种处理方式： 1）牺牲一个单元用来区分队满和队空，入队时少用一个单元 队满：Q.front (Q.rear + 1) % Maxsize 队空：Q.front Q.rear 队列中个数元素 (Q.rear + Maxsize - Q.front) % Maxsize 2）类型中增加一个size数据成员，表示元素个数。 队满：Q.size Q.Maxsize 队空：Q.size 0; 3）增加一个 tag 数据成员，删除成功 tag 设为 0，插入成功 tag 设为 1 **3. **循环队列基本操作 4 板斧 3.2.3 队列的链式存储结构 1. 队列的链式存储 含有链式队列front和rear的两个指针 不带头节时，两者都指向NULL时，链式队列为空 2. 链式队列的基本操作 4 板斧 3.2.4 双端队列 允许两端进行插入和删除操作的 线性表 双端受限某端可以的，具体分析 包吃包住 3.2.5 错题2，6，11，12，16，18 3.3 栈和队列的应用3.3.1 栈在括号匹配中的应用 胖豆都会但是得Show me code. 3.3.2 栈在表达式求值中的应用 [!tip] 左优先原则 1. 算术表达式 中缀表达式 后缀表达式 运算符后边 前缀表达式 2. 中缀表达式转后缀表达式 手算：左优先原则，然后操作就行 栈实现：得练呀 遇到 操作数 直接加入后缀表达式 遇到 界限符 ‘(’ 直接入，‘)’ 弹到胖豆出现并删除胖豆s 遇到 运算符 ： ​ -1) 若优先级 高于 栈顶的运算符或遇到栈顶为(, 直接入， ​ -2）若其优先级 **低于 **或 等于，则一次弹出栈中的运算符加入，干穿到底，或者到 -1) 停 最后将栈弹空 细节之：考虑栈的深度 // 待补充 3. 后缀表达式求值（合成大西瓜） 值 入栈 符号进行合成大西瓜 再入栈 最后栈顶（只剩一个元素即位所求答案） 2，3 可以双料特工进行 3.3.3 栈在递归中的应用 1. 递归表达式（递归体） 2. 边界条件（递归出口） 递归的精髓在于能否将原本问题转换为属性相同但规模较小的问题 关键之求递归的次数可以画出递归数 3.3.4 队列在层次遍历中的应用 理解过程和代码实现 3.3.5 队列 在计算机系统中的应用 1. 缓冲区的逻辑结构 FCFS 打印数据缓冲区，按先进先出的顺序来，也就是队列呀 2. 多队列出队入队的错做的应用 CPU中央处理器资源的竞争 3.3.6 错题7，8，16，17 3.4 数组和特殊矩阵3.4.1 数组的定义 线性表的推广 3.4.2 数组的存储结构 注意行优先还是列优先 注意下标 3.4.3 特殊矩阵的压缩存储 1. 对称矩阵 注意下标 2. 三角矩阵 注意下标和 上三角还是下三角 多存储了一个常数 C 存储空间 + 1 3. 三对角矩阵 同上 3.4.4 稀疏矩阵 三元组 和 十字链表 来存 三元组（或 十字链表）除了存储行标，列标，值，还要存矩阵行数，列数 行优先顺序遍历稀疏矩阵非0元素然后加入到三元组表 P97 转置算法 3.4.5 错题8 4. 串4.1 串的定义和实现4.1.1 串的定义 一些基本概念 4.1.2 串的基本操作 经典操作 4.1.3 串的存储结构 定长顺序存储表示 结束符为“\\0” 堆分配存储表示 分配到堆区一段连续的空间 块链存储表示 链表类似的连接起来 4.2 串的模式匹配4.2.1 简单的模式匹配算法（朴素模式匹配算法） 主串与模式串分别为 n 和 m 最多需要进行 $n - m + 1$ 趟匹配 对多 m 次比较 最坏时间复杂度为 O(mn) 4.2.2 KMP 1. 算法基本原理 不走回头路，模式串又恨多重复子串 $O( m +n)$ 时间复杂度 关键在于next数组的求解 2. 手算next数组 3. next数组的推理公式 4. 算法的实现 4.2.3 KMP算法的改进 Next*数组：目的未来减少移动的次数 4.2.4 错题8，10，13 5. 树与二叉树5.1 树的基本概念5.1.1 树的定义 一些术语 空树，根结点，子树 除了根结点以外的所有结点有且仅有一个前驱（与图的差异） 可以有0个或多个后继 5.1.2 基本术语 基本术语 1）祖先，子孙，孩子，兄弟和堂兄弟 2）层次（从(根)上往下、深度和高度 3）结点的度（孩子个数）树的度（所有结点最大的度） 4）分枝结点 和 叶结点 5）有序树和无序树 6）路径和路径长度（经过边的个数） 7）森林 5.1.3 树的性质 1）树的结点数目 $n$ 等于所有结点的度数之和再加 1 2）度为m的树第i层最多$m^{i-1}$个结点 3）高度为h的m叉树至多有有 $\\frac{(m^h-1)}{m-1}$ 4）度为m、具有n个结点的树的最小高度h为 $\\left\\lceil log_n(n(m+1)+1) \\right\\rceil$ 推导考虑前h-1层满插 5）度为m、具有n个结点的树最大高度h为 $n-m+1$ 5.1.4 错题3，4，7，8，10 5.2 二叉树的概念5.2.1 二叉树的定义及其主要特性 1. 二叉树的定义 一些重要的术语，度为2的树至少为3个，但二叉树可以为空 2. 几种特殊的二叉树 1）满二叉树 插满了 除了叶结点，其他结点度全为2 （编号从 1 开始当前结点 i，父亲有的话是 $\\lfloor i2 \\rfloor$ 左孩子 2i 右孩子 2i + 1 2）完全二叉树 略逊满二叉 只有一个度为1的非叶结点 3）二叉排序树 7.3 左子树小于根结点右子树大于根结点 4）二叉平衡树 7.3 任意结点左右子树高度差不超过1 5）正则二叉树 每个分枝结点都有2个孩子，树中只有度为0或2的结点 3. 二叉树的性质 1）非空二叉树上的叶结点个数等于度为2的结点加1，即 $n_0 n_2+1$ （总结点数为 $n n_0 + n_1 + n_2$） ​\t- $n n_1 + 2n_2 + 1$ ​\t- 这两个联立可以求结点数 完全二叉树 n1 只能是 0 或 1 2）非空二叉树的第k层最多 $2^{k-1}$ 个结点 3）高度为h的二叉树最多有 $2^h - 1$ 4）完全二叉树编号从 1，2，3 开始时 ​ - 只有一个度为1的结点且是左孩子 ​ - 最后一个分枝结点为 $\\lfloor n2\\rfloor \\ 如果 \\ i \\le \\lfloor n2\\rfloor $ 则为分枝否则叶 ​ - n为奇数分枝结点都有左右孩子，偶数最后一个分枝结点只有左孩子 ​ - 编号同满二叉树 ​ - 结点 i 所在层次（深度）$\\lfloor\\log_2i\\rfloor + 1$ 5）具有n个结点的完全二叉树高度为 $\\lceil \\log_2(n+1)\\rceil$ 或者 $\\lfloor \\log_2(n) \\rfloor + 1$ 5.2.2 二叉树的存储结构 1. 顺序存储 数组 胖豆都会 2. 链式存储 lchild data rchild 胖豆都会 n个结点n+1个空链域 5.2.3 错题12，13，19，20，22，23 5.3 二叉树的遍历和线索二叉树5.3.1 二叉树的遍历 1. 先序遍历 （前缀） 根 左 右 2. 中序遍历（中缀） 左 根 右 3. 后序遍历（后缀） 左 右 根 4. 层次遍历 使用队列 5. 由遍历序列构造二叉树 前 + 中 ｜ 后 + 中 ｜ 层 + 中 有 中 才可以构造唯一 5.3.2 线索二叉树 1. 线索二叉树的基本概念 加快寻找遍历中结点前驱和后继的速度 无左子树，lchild 指向其前驱结点，无右子树，rchild 指向其后继结点 增加两个标志域，以标识指针指向左（右）孩子或前驱（后继） 1 则为 后继或前驱 2. 中序线索二叉树的构造 胖豆推荐看视频 3. 中序线索二叉树的遍历 利用线索实现的非递归的遍历 空间复杂度为 O(1) 4. 先序线索二叉树和后序线索二叉树 后序线索二叉树中找结点的后继较为复杂，三种情况： 结点x为根，则其后继为空 若结点x是其双亲的右孩子，其双亲的左孩子且其双亲没有右子树，则后继结点为双亲 若结点x是其双亲的左孩子，且其双亲右右子树，则其后继为双亲的右子树按后序遍历列出的第一个结点 5.3.3 错题6，15，24，25，28，31，32，33，37，42，43 5.4 树、森林5.4.1 树的存储机构 1. 双亲表示法 可以很快找到双亲结点，但求结点的孩子需要遍历整个结构 用一组存储空间来存储每个结点，同时在每个结点中增设一个伪指针，指向其双亲结点在数组的位置 2. 孩子表示法 找孩子多，找双亲少 将每个结点的孩子视作一个线性表，以单链表作为存储结构，n个结点则有n个孩子链表 3. 孩子兄弟表示法 也称二叉树表示法, 左边为第一个孩子，右边指向第一个兄弟， struct CSNode ElemType data; struct CSNode *firstchild, *nextsibling; 5.4.2 树、森林和二叉树的转换 1. 树转换成二叉树 1）兄弟结点之间加一连线 2）对每个结点，只保留它与第一个孩子的连线，与其他孩子的连线全部抹掉 3）以树根为轴心，顺时针旋转45度 2. 森林转化成二叉树 1）转换每棵为二叉树 2）每棵树的根连一根线表示为兄弟关系 3）以第一棵树的根为轴顺时针旋转45度 3. 二叉树转换为森林 这边是唯一的转换 1）二叉树为非空则其根及其左子树为第一棵树的二叉树形式，将右链断开 2）对右链执行上述（1）操作 3）直至到没有右子树的二叉树为止 5.4.3 树和森林的遍历 1. 树的遍历（bupt为前序遍历，后序遍历，中序遍历，无中序遍历 三种方式叶节点顺序不变 1）先根遍历 先访问根节点 再依次遍历根节点的每个子树，遍历子树时仍然遵循先根后子树的规则 最后与对应二叉树的先序遍历相同 2）后根遍历 先一次遍历根节点的每棵子树，遍历子树时依然按照先子树后根的规则 再访问根节点 最后与对应二叉树的中序遍历相同 3）层次遍历 同理二叉树 2. 森林的遍历（前序遍历和后序遍历） 都从第一棵树开始 前序同前后同中 5.4.4 错题4，8，9，15， 5.5 树与二叉树的应用5.5.1 哈夫曼树和哈夫曼编码 1. 哈夫曼树的定义 （叶节点的）带权路径长度 $WPL \\sum_{i1}^{n}w_il_i$ 称为树的带权路径长度 带权路径最小的二叉树称为哈夫曼树，也称最优二叉树 2. 哈夫曼树的构造 构造 1）n个结点分别作为n棵含一个结点的二叉树，构成森林 F 2）构造一个新节点从F中选取结点权值最小的树作为左右子树， 并将新节点权值置为左、右子树上根节点的权值之和3）从F中删除刚才选出的两棵树，同时将新得到的树加入F中 4）重复2）3）直到只剩一棵 性质 权值越小的结点到根结点的路径长度越大 构造过程中新建了 n-1 个结点，因此哈夫曼树的结点总数为 2n - 1 每次构造都选择2棵子树作为新节点的孩子，因此不存在度为 1 的节点 3. 哈夫曼编码（可变长度编码，与之相对的是固定长度编码 左 0 右 1，胖豆是猪 5.5.2 并查集 1. 并查集合的概念 1）Initial(S)2）Union(S, Root1, Root2)3）Find(S, x) 2. 并查集的存储结构 （双亲表示法）（-1 即位根节点） 好并，好查 3. 并查集的基本实现 胖豆都会 4. 并查集实现的优化 1）改进 Union 操作 根节点的绝对值表示高度，然后Union时小的并到大的 深度不超过 $\\lfloor log_2n \\rfloor + 1$ 2）改进 Find 操作 （顺手的事） 压缩路径 循环找到根后再将循环一次将所有路径上的节点直接连到根上 5.5.3 错题6，8，9，11，13，21，22 6. 图6.1 图的基本概念6.1.1 图的定义 一些术语 顶点集 V，边集 E，有向图，无向图，简单图，多重图 度，入度（入自己的度），出度（出别人的度） 路径，路径长度（边数），回路或环（n个顶点，且有大雨n-1条边，一定有环路） 简单路径（顶点不重复的路径），简单回路（只重复第一个和最后一个） 距离（u到v最短路径存在则称为距离，若uv不存在记作∞） 子图 无向图 连通，连通图（任意顶点连通） 无向图中的极大连通子图称为连通分量 连通图：最少 n - 1 条边 非连通图：最多 $C_{n-1}^{2}$ 条边 有向图 强连通图，强连通分量 强连通图：最少 n 条边 有向图中的极大强连通子图称为强连通分量子图都是强连通的 连通图的生成树是包含图中全部顶点的一个极小连通子图 连通分量的生成树构成了生成森林 边的权，网（带权的边），带权路径长度 完全图（简单完全图）无向图满连 $n(n-1)2$ 条边 有向图乘2 稠密图、稀疏图 有向树：一个顶点的入度为0，其余顶点的入度均为 1 的有向图，称为有向树 6.1.2 错题5，6，9，11，13，16，18，二 1 6.2 图的存储及基本操作6.2.1 邻接矩阵法 胖豆都会 $O(V^2)$ 6.2.2 邻接表法 顺序+链式存储 表示方法不唯一 $O(V +2E)$ 无向 有向 $O(V+E)$ 6.2.3 十字链表法（有向图） 删顶点方便，删边不方便-邻接表 data firstin first out tailvex - headvex link tlink (data zone) headvex是箭头的开始 -，tailvex事箭头的结束 6.2.4 邻接多重表（无向图） 删顶点方便，删边不方便-邻接表 同十字链表法 6.2.5 图的基本操作 几板斧罢了 6.2.6 错题19 6.3 图的遍历6.3.1 广度优先搜索 Breadth First Search 队列实现，类似于树的层序遍历 1. 性能分析 空间复杂度 $O(|V|)$ 时间复杂度 邻接表 $O(V + E)$ 邻接矩阵 $O(V^2)$ 2. BFS求单源最短路径 非带权的单源最短路径 code 3. 广度优先生成树 邻接矩阵唯一表示，邻接表不唯一 6.3.2 深度优先搜索 回溯算法 Depth First Search 类似于树的先序遍历 1. 性能分析 与楼上一样 2. 深度优先的生成树和生成森林 对连通图调用DFS才能产生深度优先生成树 否则为生成森林 6.3.3 图的遍历与图的连通性 连通分量会导致多用一次DFS或DFS 6.3.4 错题2，9，12，14，17 6.4 图的应用6.4.1 最小生成树 去一条边变成非连通图，加一条边会形成回路 n-1 不唯一 1. Prim算法 从顶点开始扩展 $O(V^2)$ 不依赖于 $E$ 边稠密顶点稀疏 当前生成树的最小的 2. Kruskal 算法 只用邻接表 用堆 按权值递增次序选择 每次选择需要 $\\log_2E$ $O(E\\log_2E)$ 不依赖V 全局最小的形不成回路加进来 适用于边稀疏 顶点较多 6.4.2 最短路径 1. Dijkstra 算法 与Prim都是贪心 $O(V^2)$ 负权值就不太行了 2. Floyd 算法 $O(V^3)$ BFS 算法 Dijkstra 算法 Floyd 算法 用途 求单源最短路径 求单源最短路径 求各顶点之间的最短路径 无权图 适用 适用 适用 带权图 不适用 适用 适用 带负权值的图 不适用 不适用 适用 带负权回路的图 不适用 不适用 不适用 时间复杂度 $O(V^2) or O(V + E)$ $O(V^2)$ $O(V^3)$ 6.4.3 有向无环图描述表达式得看课 有向图没有环 描述公共子式的有效工具 6.4.4 拓扑排序 一些术语 AOV网（Activity On Vertex Network） 入度为0开始选择然后拆拆拆 邻接表 $O(V + E)$或者 邻接矩阵 $O(V^2)$ 1. DFS实现这个算法 检测每次的入度为0可以说明拓扑排序唯一 邻接矩阵为三角矩阵，则存在拓扑排序，反之不成立 6.4.5 关键路径细究 [!tip] 得细细研究了 加快关键活动缩短整个工期，但不能任意缩短，一定程度后，可能会变为非关键活动 关键路径并不唯一 6.4.6 错题5，7，8，11，13，14，19，20，21，24，30，33，44，45 7. 查找 查找方法 适用条件 平均时间复杂度 最坏时间复杂度 空间复杂度 说明 顺序查找 无序表 $(O(n))$ (O(n)) (O(1)) 不需要额外空间，简单但效率最低 折半查找 有序表 $(O(\\log_2 n))$ (O(\\log_2 n)) (O(1)) 仅限有序表，性能稳定 分块查找 各块有序、块间有序 $(O(\\sqrt{n}))（最优情况）$ (O(n)) (O(n)) 增加少量索引，提高查找效率 哈希查找 任意表 $(O(1))（平均）$ (O(n))（极端冲突） (O(n)) 查找最快，但需要额外散列空间 二叉排序树查找 动态查找表 $平均 (O(\\log_2 n))$ (O(n))（退化为链） (O(n)) 适合动态插删 平衡二叉树（AVL）查找 动态查找表 $(O(\\log_2 n))$ $(O(\\log_2 n))$ (O(n)) 插删代价较大但查找稳定 7.1 查找的基本概念1）查找、查找失败 2）查找表 3）静态查找表 只查不操作数据 4）关键字：数据唯一id MySql 5）平均查找长度 ASL 7.2 线性查找表：顺序查找表和折半查找7.2.1 顺序查找表1. 一般线性表1）存储结构：顺序表 链表 是否有序均可 2）时空复杂度：时间复杂度 O(n) 空间复杂度 O(1) 3）ASL：$ASL_{成功} \\frac{n+1}{2}$ $ASL_{失败} n+1$ 4）优缺点 5）特点 查找判定树 2. 有序线性表1）存储结构：顺序表 链表 是否有序均可 2）时空复杂度：时间复杂度 O(n) 空间复杂度 O(1) 3）ASL：$ASL_{成功} \\frac{n+1}{2}$ $ASL_{失败} \\frac{1+2+3+..n+n}{n+1} \\frac{n}{2} + \\frac{n}{n+1}$ 4）优缺点 5）特点 查找判定树 7.2.2 折半查找 二分1）存储结构：只适合有序顺序表 链表不可以 2）时空复杂度：时间复杂度 O(log2n) 空间复杂度 O(1) 3）ASL：$ASL_{成功} 圆形结点平均长度 \\log 2(n+1) - 1$ $ASL{失败} 方形结点平均长度 \\log_2n + 1$ 4）优缺点 5）特点 ​\t1）查找判定树右倾或左倾 对应 $\\frac{low + high}{2}$ 去上整还是下整 ​\t2）$\\left\\lceil log_n(n+1) \\right\\rceil$ 树高 ​\t3）平衡二叉树 ​\t4）查找二叉树不唯一 7.2.3 分块查找（sign记录，batch块 块内无序，块间无序，也称索引顺序查找 1）存储结构：只适合有序顺序表 链表不可以 2）时空复杂度：时间复杂度 **O(n) 最好 O($\\sqrt{n}$) ** 空间复杂度 O(n) 3）ASL：$ASL_{成功} L_1+L_s \\frac{b+1}{2} + \\frac{s+1}{2}$ 查找表为b块 每个s记录 4）优缺点 5）特点 ​\t1）空间换时间 ​\t2）$s \\sqrt{n} \\ \\Rightarrow \\ ASL_{min} \\sqrt{n} + 1$ ​\t3) 7.2.4 错题5，8，13，15，16 7.3 树形查找7.3.1 二叉排序树 BST 左 根 右 Binary Sort Tree 1）存储结构：动态查找表适合BST，如果静态选择二分 2）时空复杂度：时间复杂度 **O(log2n) ** 空间复杂度 O(n) 3）ASL：$ASL_{成功} L_1+L_s \\frac{b+1}{2} + \\frac{s+1}{2}$ 查找表为b块 每个s记录 4）优缺点 5）特点 ​\t1）中序遍历则升序排列 ​\t2）二叉排序树的删除 ​ -1. 叶子直接删 ​ -2 只有一棵子树 直接并上来 ​ -3 左右子树均有 则中序遍历的直接后继 或 直接前驱直接替代 ​\t3）查找判定树唯一 ​\t4）最小高度 $\\left\\lceil log_n(n+1) \\right\\rceil$ 或 $h \\left\\lfloor \\log_2 (n + 1) \\right\\rfloor$ 7.3.2 平衡二叉树 AVL1）存储结构：动态查找表适合BST，如果静态选择二分 2）时空复杂度：时间复杂度 **O(log2n) ** 空间复杂度 O(n) 3）ASL： 4）优缺点 5）特点 ​\t1）插入 LL RR LR RL ​\t2）删除 crux寻找最小不平衡子树 持续性搂住到底的LLRRLRRL ​ -1. 用二叉排序树的方式删除 ​ -2. 找最小不平衡子树然后开始操作 ​ -3. 向上回溯直到调整至平衡 ​\t3）树高为 $h$ 的 AVL 最少结点递推公式 ​ $n_00,n_11,n_2 2, n_h n_{h-1} + n_{h-2} + 1$ ​ 最多为满叉及 $2^h-1$ 7.3.4 错题6，9，12，15，26 7.4 B树和B+树 平衡因子均为 0 又称m路平衡查找树 7.4.1 基本操作1. 基本定义-对于m阶B树与查找（随便找）（1）每个结点最多m棵子树，最多m-1个关键字 （2）根结点不是叶结点，至少两棵子树，至少有一个关键字 （3）除根结点外的其他结点至少有 $\\left\\lceil m2 \\right\\rceil$ 棵子树，最少$\\left\\lceil m2 \\right\\rceil - 1$ 个关键字最多 $m - 1$ （4）所有叶结点（外部结点）都在同一层次上，不计入高度，查找失败的结点 2. B树高度（0）关键字+1为外部结点个数也就是叶节点 （1）每个结点的关键字个数最多，则容纳同样多的关键字的B树高度达到最小。 ​\t因此 $h \\ge log_m(n+1)$ 等比数列求和 （2）每个结点最少此时高度最大 ​\t可以反推，查找不成功的叶结点有 $n+ 1$ 个 $n + 1\\ge2(\\left\\lceil m2 \\right\\rceil)^{h-1}$ ​\t即可推出树高 3. B树插入得分裂就完了 插入新的都是先到终端节点 4. B树删除1）直接删除没啥事的话 2）兄弟够借 左兄弟，前驱的前驱 右兄弟，后继的后继 3）兄弟不够借的话合成大西瓜 7.4.2 B+树 直接连接没有左右孩子 链表结构 **特性：**对于 m 阶B+树 1）每个分枝结点做多m棵子树 2）子树最少同B树 3）结点的子树个数与关键字个数相等 4）所有叶结点包括相应记录，也就是才能找到信息，必须遍历到叶结点，可重复出现可爱胖豆结点 ​\t相邻叶结点作链表连接起来，也就是可以顺序查找 5）所有分枝结点仅包含它的各个子结点中关键字的最大值及其子结点的指针（不保存信息） 差异： 如上 - 7.4.3 错题1，3，6，7，10，11，12，19，24 7.5 散列表7.5.1 Hash表 哈希表，不需要一直比较，前面的小卡拉米才需要 用哈希函数来存映射关系 7.5.2 散列函数构造方法 函数选择： 1）定义域包含 全部关键字，值域散列表大小 2）地址应尽量 均匀分布整个地址空间，尽可能减少冲突 3）三裂函数应该简单 减少计算时间 关键字对应的散列地址 1. 直接定址法（关键字基本连续，线性的） $H(key) key$ or $a * key + b$ 2. 除留余数法（通用：除数选择大于表长的最大质数） $H(key) key \\ % \\ p$ 3. 数字分析法（关键字集合已知，且关键字的某几个数分布均匀，如电话号码）如电话号码 4. 平方取中法（关键字的每位取值都不够均匀）给关键字平方后选取其中几位 7.5.3 处理冲突的办法1. 开放定址法 关键是选择 $d_i$$H_i (H(key) + d_i) %m$ m为散列表表长 1）线性探测法 $d_i 1,2,3,…$ 2）平方探测法 $d_i 1^2,-1^2,2^2,-2^2,3^3……$ 正负交替 3）双散列法 $H_i (H(key) + i Hash_2(key)) %m$ $d_i iHash_2$ 4）伪随机数列法 $人为选取d_i$ 2. 拉链法（连接法，chaining）默认头插7.5.4 性能分析1. ASL2. 影响查找效率三个因素：散列函数，处理冲突办法，装填因子$\\alpha \\frac{表中记录数n}{散列表长度m}$ 越满越容易冲突，反之越不容易 7.5.5 错题1，2，4，5，6，7，13，21，23 8. 排序8.1 排序定义 关键词 稳定性 8.2 插入排序 每次将一个待排序的记录 按其关键字大小 排序到前面已经排好序的序列中 8.2.1 直接插入排序 适合基本有序 正序 比较次数 $n - 1$，移动次数为0，逆序 比较次数 $\\sum {i2}^ni$ 移动次数 $\\sum{i2}^n(i+1)$ [!tip] 稳定！但依赖排序表的初始顺序 存储结构：顺序存储 或 链式存储的线性表 空间复杂度：$O(1)$ **时间复杂度：**最好：$O(n)$ 最坏 $O(n^2)$ 平均 $O(n^2)$ 特点： 8.2.2 折半插入排序 [!tip] 稳定！用二分查找来缩短插入到已排序好的序列中的位置 存储结构：仅 顺序存储的线性表 空间复杂度：$O(1)$ **时间复杂度：**最好：$O(n)$ 最坏 $O(n^2)$ 平均 $O(n^2)$ 特点： ​ - 仅减少了比较次数 ，并没有减少移动次数 ​ - 比较次数与待排序表的初始状态无关，仅取决于元素格式 ​ - 但移动次数仍然依赖于表的初始状态 8.2.3 希尔排序 [!caution] 不稳定！ 算法步骤 分成若干个字表对字表进行直接插入排序 基本有序时，再对全体记录来一次插入排序 存储结构：仅 顺序存储的线性表 空间复杂度：$O(1)$ 时间复杂度：n在某个特定范围 $O(n^1.3)$ 最坏 $O(n^2)$ 平均 $O(n^2)$ 特点： 8.2.4 错题1，10，12 8.3 交换排序 是根据序列中两个元素关键字的比较结果来对换这两个记录中的位置 8.3.1 冒泡排序 起泡排序 正序 比较次数为 n - 1， 移动次数为0， 逆序 比较次数 $\\sum_{i1}^{n-1}(n-i)$, 移动次数 $3\\sum_{i 1}^{n-1}(n-1)$ [!tip] 稳定！每次冒到末尾最大可以加个 bound pos，来提速 存储结构：顺序存储和链式存储的线性表 空间复杂度：$O(1)$ **时间复杂度：**最好：$O(n)$ 最坏 $O(n^2)$ 平均 $O(n^2)$ 特点： ​ - 最坏情况下的 比较次数 $\\frac{n(n - 1)}{2}$ 和移动次数 $\\frac{3n(n-1)}{2}$ 8.3.2 快速排序 [!caution] 不稳定！ 选取pivot作为枢纽，然后划分为左右两部分，直到划分到只剩一个 pivot可选择首个 存储结构：仅 顺序存储的线性表 **空间复杂度：**最好：平衡二叉树树高 $O(\\log_{2} n)$ 链表$n-1$ 次 $O(n^2)$ 平均 $O(\\log_{2} n)$ **时间复杂度：**最坏 $O(n^2)$ 理想状态 $O(n \\log_2 n)$ 特点： 8.3.3 错题9，10，18 8.4 选择排序 每一趟在待排序元素中选取关键字最小的元素，作为有序子序列第i哥元素，直到 n- 1 趟，游戏结束 8.4.1 简单选择排序 移动次数最少正序 比较次数为 $\\sum_{i1}^{n-1}(n-i)$ 移动次数为 0 逆序 比较次数为 $\\sum_{i1}^{n-1}(n-i)$ 移动次数为 $3(n-1)2$ [!caution] 不稳定！ 存储结构：顺序存储和链式存储的线性表 空间复杂度：$O(1)$ 时间复杂度： 固定节目 $O(n^2)$，移动次数少不会超过 $3(n-1)$ 但比较次数始终是 $\\frac{n(n-1)}{2}$ 特点： 8.4.2 堆排序 [!caution] 不稳定！ 存储结构：仅 顺序存储线性表 空间复杂度：$O(1)$ 时间复杂度： 建堆 $O(n)\\ \\ n - 1$ 次调整每次最多 $O(h)$ 所以最后 $O(n \\log n)$ 特点： 一棵完全二叉树， 大根堆根结点最大，小根堆根结点最小 建堆：以大根堆为例，1️⃣从最后一个双亲结点开始遍历也就是 $\\left\\lfloor \\frac{n}{2} \\right\\rfloor$往前遍历$\\left\\lfloor \\frac{n}{2} \\right\\rfloor$- 1 ​ 2️⃣左右比较交换到当前根使之最大 ​ 3️⃣交换的另一个需要考虑**“沉底”** 建堆时间与树高有关，$O(h)$ 总比较次数不超过 $4n$ 时间复杂度为 $O(n)$ 堆排序：最后结点与根结点交换，然后根结点沉底就行 8.4.3 错题2，5，6，7，11，19，21 8.5 归并排序、基数排序、计数排序 哥三和上面的排序想法不太一样 8.5.1 归并排序 [!tip] **分治！**稳定！ Merge()很重要 先将含有n个的待排序表分成含 n2 子表，采用二路归并算法对两个字表递归地进行排序 存储结构：顺序存储和链式存储的线性表 空间复杂度：$O(n)$ 时间复杂度： $每趟为 \\ log_2n \\ 一共为\\ O(n\\log n)$ 特点： ​ $\\left\\lceil \\frac{n}{2h} \\right\\rceil$ 次 Merge() 需要 $\\left\\lceil log_2n \\right\\rceil$ 趟 8.5.2 基数排序 [!tip] **不基于比较和移动！**稳定！ 以 r 为基数则 使用 r 个队列 MSD 和 LSD 存储结构：顺序存储和链式存储的线性表 空间复杂度：$O(r)$ 时间复杂度： $O(d(n+r))$ 一趟遍历一遍n个数字同时合并r个队列 d趟 特点： 8.5.3 计数排序 [!tip] **拿信息的胖豆！**稳定！ 整型变量存储 范围 [0, k) 从后往前保证稳定 为了找到小与某个的值的个数数组B，最终敲定位置C 存储结构：更适合顺序存储和链式存储的线性表 空间复杂度：$O(n + k)$ n 来自计数数组 B，k 来自 辅助数组C 时间复杂度： $O(n + k)$ 特点： ​ - k O(n) 时，这东西比比较的排序快排, 堆排序快 ​ k $O(n \\log_2n)$ 那就太逊了 8.5.4 错题3，8，11，18 8.6 原神玩家大杂烩8.6.1 内部排序算法的比较 8.6.2 内部排序算法的应用 8.6.3 错题3，4，6，8，9，12，14，15， 8.7 拓展：桶排序考纲","tags":["test1"]},{"title":"Paodou","path":"/2026/01/03/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new My New Post More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment"}]